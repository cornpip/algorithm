### 그래프 구현의 2가지 방식  
+ 인접 행렬:   
공간복잡도 O(V^2)  
A노드에서 B노드로 이어진 간선 비용을 시간 O(1)로 즉시 알 수 있다.

+ 인접 리스트:   
공간복잡도 O(E)  
A노드에서 B노드로 이어진 간선 비용을 시간 O(V) 만큼의 시간 소요 _( V는 인접 노드수 일 듯 )_

### 서로소 집합 알고리즘
얘의 시간복잡도 고려부분은
```
for i in range(1, v+1):
    print(find_parent(parent, i), end=' ')
```
이 부분인 듯 하다.
+ 기본 : O(VM)  
+ 경로 압축 : 대략 O(V + M(1+logV))

_( M=find or union 연산 )_  
시간복잡도 값은 직관으로 받아들이자.  

### 사이클 판별 알고리즘 
무방향만 가능하다.

### 신장 트리
하나의 그래프가 있을 때 모든 노드를 포함하면서 사이클이 존재하지 않는 부분 그래프  
_( 이때 모든 노드가 포함되어 서로 연결되면서 사이클이 존재하지 않는다는 조건은 트리의 성립 조건이기도 하다. )_

### 크루스칼 알고리즘
최소 신장 트리 알고리즘  

시간복잡도
+ O(ElogE) _( 정렬 시간복잡도 )_  
_E = 간선 개수_  
_내부에서 사용되는 서로소 집합 알고리즘의 시간은 정렬 알고리즘의 시간복잡도 보다 작으므로 무시한다. ~~(?)~~_  
_서로소 알고리즘의 속한 집합 결과로 출력하는 부분 없다._  
_크루스칼은 속한 집합이 아닌 간선 비용이 목적_  

>크루스칼 알고리즘으로 최소 신장 트리를 찾은 후 가장 비용이 큰 간선 제거하면 2개의 최소 신장 트리로 나눠진다.

### 위상 정렬 알고리즘
방향 그래프의 모든 노드를 '방향성에 거스르지 않도록 순서대로 나열하는 것'  

사이클이 존재하는 경우 사이클에 포함되어 있는 원소는 큐에 들어가지 못한다.  

사이클이 없다 == 노드를 한번씩 방문한다.  
_기본적으로 위상 정렬 문제에서는 사이클이 발생하지 않는다고 명시하는 경우가 더 많다 한다._  
_사이클이 있다면 지금 알고리즘으로 안된다._  

인접 리스트를 담을 때 상위 노드를 담아야 한다.  
1 --> 2 라면 1번노드에 2를 담아야 함 _(하위는 상위 노드를 갖고 있다)_  
예를 들어 2번노드에 1을 담으면 시작이 없다.

<img src="https://user-images.githubusercontent.com/74674780/159152822-22a9ed31-c6f9-4c7e-bd04-14fee8c5bd8c.PNG" width=450>   
  
그래프가 위와 같다면 노드 3,6도 2,5처럼 같은 레벨인 듯 하다. _( 출력에서 바뀔 수 있는 순서 )_  

시간 복잡도 : O(V+E)  
_모든 노드를 확인하면서 간선을 제거하므로_  

---
입력 -> 연산 -> 입력 -> 연산 ... 상관없듯이  
입력 -> 출력 -> 입력 -> 출력 ... 도 상관없는 듯 하다.