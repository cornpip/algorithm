루프문이 그때 그때 변수에 의해 찍히는 코드는 지양하자.  

간단한 목적에 루프가 겹치는 것 같다 싶으면 다이나믹 접근 생각해보자.  
_가장 쉽게 생각할 수 있는 것 :_   
_입력값 범위만 적당하다면 다이나믹 고려할 수 있다._  

구현은 알고리즘 시작의 필요없는 부분을 잘 걸러네야 짧아진다.  
_루프 돌릴 필요없는 부분까지 들고가면 예외처리가 많아지고 효율성도 떨어짐_

## 다시 볼 문제
만들 수 없는 금액 : "target 보다 작으면 만들 수 있다." 가 왜 인지는 모른다. 일단 느낌으로 받아들이자.

무지의 먹방 라이브 : 효율성 제한사항을 기반으로 루프를 생각하자.  

문자열 압축 : 구현이 if, for문이 많으면 테스트하면서 예외처리하는 느낌으로 되네.... 모범 답안을 많이 익혀두자  

자물쇠와 열쇠:  

뱀:  

외벽점검: 원에 대한 포지션 접근 아이디어  

연구소: 실수를 없애고 간결하게 하는 연습

---
프로그래머스는 input을 따로 안받고 제시된 변수에 이미 담겨진채로 시작할 수 있나보다.  

|N| logN | NlogN |
|--|--|--|
|200,000 | 약18 | 3,600,000
|1,000,000| 약20 | 20,000,000
|5,000,000| 약22 | 1억 1천
|10,000,000| 약23 | 2억 3천

대충 NlogN 쓸만한 N범위는 100만  

## python 관련
_이코테 폴더 readme에 다 작성하려했는데 많아져서 여기도 추가_

### list err
```
a = "testtest"
a[5:12]
a[10:12]
# err로 실행취소되지 않는다.

a[9]
# 특정 index 짚는건 err

b = [1,2,3,4,5,6,7]
# str뿐 아니라 list도 동일한 결과 
```  
### for문 증감문
```
for i in range(0, len(s), step):
```

### if else 한줄
```
result = A if 조건 esle B
# 참이면 A 거짓이면 B
```

### zip
```
A = [1,2,3]
B = [4,5,6]

for node in zip(A, B):
    print(node, type(node))

# (1, 4) <class 'tuple'>
# (2, 5) <class 'tuple'>
# (3, 6) <class 'tuple'>
```
기본적으로는 위의 느낌으로 각 원소 엮어서 튜플로 반환한다.
```
alist = [[1,2,3], [4,5,6], [7,8,9]]

for i in zip(*alist):
    print(i)

# (1, 4, 7)
# (2, 5, 8)
# (3, 6, 9)
```
2차원 리스트는 보통 다음과 같이 사용한다.  
`*`기호를 붙여야 col끼리 엮어준다. _( 2차원 리스트는 `*`기호없이는 zip이 기대대로 동작하지 않는다. )_  

### *args
```
def func1(*args):
    
    print(args, type(args))
    print(*args, end='\n\n')
    
    for i in args:
        print(i)

func1(1, 2, 3, 4)

# (1, 2, 3, 4) <class 'tuple'> 
# 1 2 3 4 
# 1 
# 2 
# 3 
# 4
```
파라미터를 몇개 받을지 모르는 경우 사용하며 튜플형태로 전달된다.  

### list 끼리 부등호
```
[1,2,3] < [1,3,1]
# true
[5,10] < [5,10,5]
# true
```  
비교 가능하다. 첫 번째 원소부터 비교한다. 같으면 다음 원소로 판단  
길이가 달라도 판단 가능하다. 길이 무관하게 첫 번째 원소부터 비교, 없는 원소부터는 있는 쪽이 큰 것으로 판단된다.