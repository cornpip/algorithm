### 다익스트라 최단 경로
-> 방문하지 않은 노드 중 가장 최단 거리가 짧은 노드를 선택  
-> 인접 노드의 최단 거리 _( 더 짧으면 )_ 갱신  
-> 반복  

선택된 노드는 '최단 거리' 가 이미 확정된 노드다.  
그 확정된 '최단 거리'를 기반으로 인접 노드들의 '최단 거리'를 갱신하는 것

이렇게 선택된 노드는 알고리즘 반복해도 새로 갱신되지 않는다. _( 확정된 것이므로 당연히 그래야함 )_   
_( 그래서 사실 마지막 노드는 확인하지 않아도 무관하다. )_  
### 시간복잡도
다익스트라 시간복잡도는 O(V^2) 이다.  
_( V는 노드의 개수를 의미함 )_  

개선된 다익스트라의 시간복잡도는 최악의 경우에도 O(ElogV) 를 보장한다.  
_( E는 간선의 개수를 의미함 )_  

E의 최대의 경우가 V^2 이므로 ElogE = ElogV^2 = 2ElogV = ElogV 가 된 것

### 힙 자료구조와 우선 순위 큐
'우선순위 큐' 를 구현하기 위해 사용하는 자료구조 중 하나가 Heap이다.  
~~?? 그래서 힙 자료구조는 뭐지~~  
![Heap자료구조](https://user-images.githubusercontent.com/74674780/158624732-4f6a76df-f43e-457b-aa9e-d52138dac9b6.PNG)

완전 이진 트리의 일종  
_완전 이진 트리란? 대충 왼쪽부터 차있어야하고 마지막레벨은 꽉 차 있지 않아도 되는 구조_  
저런 구조를 기반으로 삽입, 삭제한다.

| 우선순위 큐 구현 방식 | 삽입 시간 | 삭제 시간 |
| -------------------| ---------| -----------|
| 리스트 | O(1) | O(N)|
| 힙(Heap) | O(logN) | O(logN) |

그래서 N개의 데이터를 모두 넣은 뒤에 모든 데이터를 꺼내는데 걸리는 시간복잡도는  

리스트 일 때: O(N^2)  
힙 구조일 때: O(NlogN)  _( 2NlogN 빅오 표기해서 )_ 

_리스트 N^2은 삭제할 때 시간복잡도 ( 넣을 때는 복잡도X )_  

heapq 기본적으로 튜플의 첫 번째 원소 기준으로 우선순위 큐를 구성한다.

### 라이브러리 PriorityQueue, heapq
둘 다 하나의 데이터를 삽입, 삭제할 때 시간복잡도는 O(logN) 이다.  
통상적으로 heapq가 조금 더 빠르게 동작한다.  

둘 다 기본값은 최소힙에 기반한다.  

### 플로이드워셜
시간복잡도: O(V^3)  
최종 return: 최단 경로값을 인접 행렬로 나타낸다. 

점화식같은 식을 만든다. ==> 다이나믹 프로그래밍으로 볼 수 있다.  
_( 다익스트라는 그리디 알고리즘 이다. )_  

distance가 graph에 포함돼있다.

---
'점화식 기반으로 짠다' == 다이나믹 프로그래밍 이라 봐도 될 것 같다.  
_( '캐싱을 한다' 기준도 틀린건 아닌데 알고리즘에선 '점화식 기반으로 짠다'를 기준으로 보자. )_